'---------------------------------------------------------------------------------
' Copyright (c) 2018 Calypso Networks Association https://www.calypsonet-asso.org/
'
' See the NOTICE file(s) distributed with this work for additional
' information regarding copyright ownership.
'
' This program and the accompanying materials are made available under the
' terms of the Eclipse Public License 2.0 which is available at
' http://www.eclipse.org/legal/epl-2.0
'
' SPDX-License-Identifier: EPL-2.0 4
'---------------------------------------------------------------------------------

@startuml(id=PLUGIN_FACTORY_1_0_0)
+interface PluginFactory {
  +String getPluginName()
  +Plugin getPluginInstance()
}
@enduml

@startuml(id=PLUGIN_OBSERVABLE_NOTIFIER_1_0_0)
+interface ObservablePluginNotifier {
  +notifyObservers(<b>final</b> PluginEvent event)
}
@enduml

@startuml(id=READER_OBSERVABLE_NOTIFIER_1_0_0)
+interface ObservableReaderNotifier {
  +notifyObservers(<b>final</b> ReaderEvent event)
}
@enduml

@startuml(id=PLUGIN_SMART_SELECTION_1_0_0)
+interface SmartSelectionReader {
  +ApduResponse <color:blue>openChannelForAid</color>(AidSelector aidSelector)
  +<color:blue>closeLogicalChannel()</color>()
}
@enduml

@startuml(id=PLUGIN_SMART_OBSERVABLE_1_0_0)
+interface SmartInsertionReader  {
  +boolean <color:blue>waitForCardPresent</color>()
  +<color:blue>stopWaitForCard</color>()
}

+interface SmartRemovalReader {
  +boolean <color:blue>waitForCardAbsentNative</color>()
  +<color:blue>stopWaitForCardRemoval</color>()
}
@enduml

@startuml(id=PLUGIN_PLUGIN_1_0_0)
+abstract AbstractPlugin {
  -<b>final</b> String name
  #ConcurrentMap<String, Reader> readers
  --
  #{abstract} AbstractPlugin(String name)
'
  .. implementation of the package interface ProxyElement ..
  +<b>final</b> String getName()
'
  .. implementation of the public interface Plugin ..
  +<b>final</b> Set<String> getReaderNames()
  +<b>final</b> Reader getReader(String name)
  +<b>final</b> Map<String, Reader> getReaders()
'
  .. protected abstract method to be implemented by <color:blue>native</color> Plugin ..
  #{abstract} Map<String, Reader> <color:blue>initNativeReaders</color>()
}
@enduml

@startuml(id=PLUGIN_OBSERVALEPLUGIN_1_0_0)
+abstract AbstractObservablePlugin << <color:red>internal / dedicated</color> for RemotePlugin >>{
  -List<PluginObserver> observers
  -<b>final</b> final Object sync
  --
  #AbstractObservablePlugin(String name)
'
  .. implementation of the public interface ObservablePlugin ..
  +addObserver(<b>final</b> PluginObserver observer)
  +removeObserver(<b>final</b> PluginObserver observer)
  +clearObservers()
  +<b>final</b> int countObservers()

  .. implementation of the public interface ObservablePluginNotifier ..
  +<b>final</b> notifyObservers(<b>final</b> PluginEvent event)
}

+abstract AbstractThreadedObservablePlugin {
  -{static}<b>final</b> long SETTING_THREAD_TIMEOUT_DEFAULT
  -long threadWaitTimeout
  -<b>final</b> SortedSet<String> nativeReadersames
  -EventThread thread
  --
  #AbstractThreadedObservablePlugin(String name)
'
  .. Override of the implentation of the public interface ObservablePlugin ..
  +<b>final</b> addObserver(<b>final</b> PluginObserver observer)
  +<b>final</b> removeObserver(<b>final</b> PluginObserver observer)
  +<b>final</b> clearObservers()

  .. protected abstract methods to be implemented by <color:blue>native</color> ObservablePlugin ..
  #{abstract} SortedSet<String> <color:blue>fetchNativeReadersNames</color>()
  #{abstract} Reader <color:blue>fetchNativeReader</color>(String name)
'
  .. internal process ..
  .. To review - used by unit test Stub & Remote Plugin ..
  #Boolean isMonitoring()
}
@enduml

@startuml(id=PLUGIN_ABSTRACTREADER_1_0_0)
+abstract AbstractReader {
  -<b>final</b> String pluginName
  --
  #AbstractReader(String pluginName, String name)
  #<b>final</b> String getPluginName()
'
  .. implementation of the package interface ProxyElement ..
  +<b>final</b> String getName()
'
  .. implementation of tbe public interface ProxyReader ..
  +<b>final</b> List<SeResponse> transmitSeRequests(List<SeRequest seRequests, MultiSeRequestProcessing
    multiSeRequestProcessing, ChannelControl channelControl)

  +<b>final</b> SeResponse transmitSeRequest(SeRequest seRequest, ChannelControl channelControl)
'
  .. protected abstract methods to be implemented by AbstractLocalReader or VirtualReader ..
  #{abstract} List<SeResponse> processSeRequests(List<SeRequest> seRequests,
    MultiSeRequestProcessing multiSeRequestProcessing, ChannelControl channelControl)

  #{abstract} SeResponse processSeRequest(SeRequest seRequest, ChannelControl channelControl)
}
@enduml

@startuml(id=PLUGIN_LOCALREADER_1_0_0)
+abstract AbstractLocalReader {
  -{static}<b>final</b> byte[] getResponseHackRequestBytes
  -boolean logicalChannelIsOpen
  -CardSelector.AidSelector.IsoAid aidCurrentlySelected
  -SelectionStatus currentSelectionStatus
'  -long before
  -Map<String, String> protocolsMap
  --
  #AbstractLocalReader(String pluginName, String name)'
  .. implementation of the public interface SeReader ..
'  +<b>final</b> +boolean isCardPresent()
'  +<b>final</b> +activateProtocol(String applicationReference, String pluginReference)
'  +<b>final</b> +deactivateProtocol(String applicationReference)
  +boolean isCardPresent()
  +activateProtocol(String applicationReference, String pluginReference)
  +deactivateProtocol(String applicationReference)
'
  .. implementation of the protected abstract methods of the class AbstractReader ..
  #<b>final</b> List<SeResponse> processSeRequests(List<SeRequest> seRequests,
    MultiSeRequestProcessing multiSeRequestProcessing, ChannelControl channelControl)

  #<b>final</b> SeResponse processSeRequest(SeRequest seRequest, ChannelControl channelControl)
'
  .. protected abstract methods to be implemented by <color:blue>native</color> SeReader ..
  #{abstract} String <color:blue>getProtocolReference</color>()
  #{abstract} boolean <color:blue>checkCardPresence</color>()

  #{abstract} <color:blue>openPhysicalChannel</color>()
  #{abstract} <color:blue>closePhysicalChannel</color>()
  #{abstract} boolean <color:blue>isPhysicalChannelOpen</color>()

  #{abstract} byte[] <color:blue>getATR</color>()
  #{abstract} byte[] <color:blue>transmitApdu</color>(byte[] apduIn)
  .. internal process ..
  #<b>final</b> Map<String, String> getProtocolsMap()

  -ApduResponse recoverSelectionFciData(CardSelector.AidSelector aidSelector)
  -ApduResponse processExplicitAidSelection(CardSelector.AidSelector aidSelector)
  -SelectionResponse processSelectionRequestLogical(SelectionRequest sRequest)
  -CardResponse processCardRequestLogical(CardRequest cRequest)
  -ApduResponse processApduRequest(ApduRequest apduRequest)
  -ApduResponse case4HackGetResponse(int originalStatusCode)

  ~SelectionStatus openLogicalChannel(CardSelector selector)
  ~<b>final</b> SelectionStatus openLogicalChannelAndSelect(CardSelector selector)
  ~<b>final</b> boolean isLogicalChannelOpen()
  -closeLogicalChannel()
  ~closeLogicalAndPhysicalChannels()
  ~{abstract} terminateSeCommunication()
}
@enduml

@startuml(id=PLUGIN_OBSERVABLEREADER_1_0_0)
+abstract AbstractObservableLocalReader {
  -DefaultSelectionsRequest[0..1] defaultSelectionsRequest
  -ObservableReader.NotificationMode notificationMode
  -ObservableReader.PollingMode currentPollingMode
  -ObservableReaderStateService stateService
  --
  #AbstractObservableLocalReader(String pluginName, String readerName)
'
  .. implementation of the public interface ObservableReader ..
  +<b>final</b> addObserver(ReaderObserver observer)
  +<b>final</b> removeObserver(ReaderObserver observer)
  +<b>final</b> clearObservers()
  +<b>final</b> int countObservers()

  +<b>final</b> setDefaultSelectionRequest(AbstractDefaultSelectionsRequest selectionsR,
      NotificationMode notificationM, PollingMode[0..1] pollingM)

  +<b>final</b> startCardDetection(ObservableReader.PollingMode pollingMode)
  +<b>final</b> stopCardDetection()
  +<b>final</b> finalizeCardProcessing()
'
  .. implementation the public interface ObservableReaderNotifier ..
  +<b>final</b> notifyObservers(<b>final</b> ReaderEvent event)
'
  .. protected abstract method to be implemented by <color:blue>native</color> ObservableReader ..
  #{abstract} ObservableReaderStateService <color:blue>initStateService</color>()

  .. internal process ..
  .. protected method that could be overridden by <color:blue>native</color> not thread-based ..
  .. ObservableReader in Core API 0.9 => will be hidden in version 1.0 ..
  #<color:blue>onEvent</color>(InternalEvent event)
'

  ~terminateCardCommunication()

  ~startRemovalSequence()
  ~<b>final</b> ReaderEvent processCardInserted()
  ~<b>final</b> processCardRemoved()
  ~ObservableReader.PollingMode getPollingMode()
  ~switchState(AbstractObservableState.MonitoringState stateId)
  ~AbstractObservableState.MonitoringState getCurrentMonitoringState()
  ~boolean isCardPresentPing()
}
@enduml

@startuml(id=PLUGIN_POOLPLUGIN_1_0_0)
+abstract AbstractPoolPlugin {
  #AbstractPoolPlugin(String name)
}
@enduml